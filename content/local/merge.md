合併分支
=======


> 本節所提語法：
>   - git merge <分支名 / 版本號碼>
>   - git merge --no-ff <分支名 / 版本號碼>
>   - git rebase <基底分支名 / 版本號碼>
>   - git rebase <基底分支名 / 版本號碼> <嫁接分支名 / 版本號碼>



## 合併

當為了某種需求而開創的分支完成任務後，運行合併指令將其合併回主幹：

```sh
# 所在分支： master（基底分支）
$ git merge <分支名_1 / 版本號碼>[ <分支名_2 / 版本號碼>][ ...]
```

```
              D---E---F 分支_1
             /
    A---B---C  master

        ||
        \/
    
    A---B---C---D---E---F master, 分支_1
```

合併指令會以所在分支為基底，不改變原分支分離的節點，將所有指定的分支合併回當前基底分支。

強調「不改變原分支分離的節點」是合併指令（`merge`）和嫁接指令（`rebase`）的不同之處，將在下段提及。



## 嫁接

若有兩分支皆在同一節點發展出各自的版本，在合併時，分支會照舊依此分離的節點出發，此時版本線圖會分岔並生成新的紀錄點。

```
              F---G---H 分支_1
             /
    A---B---C---D---E  master

        ||
        \/

               --------F---G---H
             /                   \
    A---B---C---D---E-------------J master, 分支_1
                             （J 是合併生成的新紀錄點）
```

通常為了使版本線圖一目了然是不希望看到此結果，所以會先嫁接（`rebase`）後才合併分支。

```sh
# 所在分支： 分支（嫁接分支）
$ git rebase <基底分支名 / 版本號碼>

# 指定嫁接分支
$ git rebase <基底分支名 / 版本號碼> <嫁接分支名 / 版本號碼>
```

```
              F---G---H 分支_1
             /
    A---B---C---D---E  master

        ||
        \/

                      F---G---H 分支_1
                     /
    A---B---C---D---E  master
```

有趣的是嫁接也可看作另類的合併指令：（以分支當基底嫁接 master）

```sh
# 所在分支： master（基底分支）
$ git rebase <分支名>
```


## 保留分支線圖

版本線圖當然要是維持一目了然，那為何要保留分支線圖呢？這樣就會出現岔線圖不是嗎？

沒有錯，版本線圖是會分岔出去，但分支通常是為了某功能而創建，保留其線圖也能凸顯各個功能的版本紀錄。~~（有時也會變成某人的版本紀錄）~~


```sh
$ git rebase <基底分支名 / 版本號碼>
$ git merge --no-ff <分支名 / 版本號碼>
```

```
              F---G---H 分支_1
             /
    A---B---C---D---E  master

        ||
        \/

                      -F---G---H
                     /           \
    A---B---C---D---E-------------J master, 分支_1
                             （J 是合併生成的新紀錄點）
```

為了直覺了解版本線圖當然還是要 `rebase` 一下，而且都為了更直覺的線圖了，所以__不建議一次合併多支分支__，還是以一次一支來做合併。



## 參考資料

  - [Git - 分支的新建與合併](https://git-scm.com/book/zh-tw/v1/Git-分支-分支的新建與合併)
  - [Git - 分支的衍合](https://git-scm.com/book/zh-tw/v1/Git-分支-分支的衍合)

